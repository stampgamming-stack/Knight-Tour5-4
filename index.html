<!DOCTYPE html>
<html lang="th">
<head>
<meta charset="UTF-8">
<title>Knight Tour 5√ón (n ‚â§ 21)</title>
<style>
  body{
    background:#111; color:#fff; margin:0; min-height:100vh;
    display:flex; flex-direction:column; align-items:center; font-family:sans-serif;
  }
  #boardContainer{ flex:1; display:flex; align-items:center; justify-content:center; }
  #board{ display:grid; position:relative; }
  .cell{
    width:42px;height:42px; display:flex; align-items:center; justify-content:center;
    font-size:11px; font-weight:bold; user-select:none; cursor:pointer;
  }
  .white{background:#eee;color:#000}
  .black{background:#333}
  .start{background:#ffe600!important;color:#000}
  .blocked{background:#8b0000!important}
  .current{outline:3px solid rgba(0,255,255,.8); outline-offset:-3px;}
  .illegalFlash{animation:flash .18s ease-in-out 2;}
  @keyframes flash{ 0%{filter:brightness(1)} 50%{filter:brightness(2)} 100%{filter:brightness(1)} }
  svg{position:absolute;top:0;left:0;pointer-events:none}
  #ui{text-align:center;padding-bottom:20px}
  button,input{margin:4px}
  .hint{opacity:.85;font-size:12px;margin-top:6px;max-width:860px; line-height:1.4}
  .modeBox{display:inline-flex;gap:10px;align-items:center;justify-content:center;margin:6px 0}
  .modeTag{font-size:12px;opacity:.9}
  kbd{background:#222;border:1px solid #444;border-bottom-width:2px;padding:0 6px;border-radius:6px}
  .hidden{display:none}
</style>
</head>
<body>


  <div id="boardContainer">
    <div id="board"></div>
  </div>


  <div id="ui">
    <h3>Knight‚Äôs Tour 5 √ó n (1‚Äì21)</h3>


    <div class="modeBox">
      <label class="modeTag">
        <input type="checkbox" id="manualToggle">
        ‡πÇ‡∏´‡∏°‡∏î‡πÇ‡∏¢‡∏á‡∏°‡∏∑‡∏≠‡πÄ‡∏≠‡∏á (MANUAL)
      </label>
      <span class="modeTag" id="modeLabel">‡∏ï‡∏≠‡∏ô‡∏ô‡∏µ‡πâ: AUTO (‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡πÉ‡∏´‡πâ)</span>
    </div>


    <div>
      n :
      <input id="cols" type="number" value="11" min="1" max="21"><br>


      ‡∏à‡∏∏‡∏î‡πÄ‡∏£‡∏¥‡πà‡∏° (‡πÅ‡∏ñ‡∏ß,‡∏Ñ‡∏≠‡∏•‡∏±‡∏°‡∏ô‡πå):
      <input id="startInput" placeholder="‡πÄ‡∏ä‡πà‡∏ô 1,1" value="3,1"><br>


      ‡∏ï‡∏±‡∏î‡∏ä‡πà‡∏≠‡∏á (0‚Äì2 ‡∏ä‡πà‡∏≠‡∏á):
      <input id="blockInput" placeholder="‡πÄ‡∏ä‡πà‡∏ô 2,3 ‡∏´‡∏£‡∏∑‡∏≠ 2,3;4,5" value="3,3"><br>
    </div>


    <!-- ‡∏õ‡∏∏‡πà‡∏°‡πÇ‡∏´‡∏°‡∏î AUTO -->
    <div id="autoControls">
      <button id="runBtn" onclick="runOrSkip()">‚ñ∂ Run / Skip</button>
      <button onclick="prev()">‚óÄ</button>
      <button onclick="next()">‚ñ∂</button>
      <button onclick="resetAll()">Reset</button>
      <div class="hint">
        AUTO: ‡∏ö‡∏±‡∏á‡∏Ñ‡∏±‡∏ö‡∏´‡∏≤ ‚Äú‡∏Ñ‡∏£‡∏ö‡∏ó‡∏∏‡∏Å‡∏ä‡πà‡∏≠‡∏á‡∏ó‡∏µ‡πà‡πÄ‡∏´‡∏•‡∏∑‡∏≠‚Äù ‡πÅ‡∏•‡∏∞ ‚Äú‡∏õ‡∏¥‡∏î‡∏ß‡∏á‡∏Å‡∏•‡∏±‡∏ö‡∏à‡∏∏‡∏î‡πÄ‡∏£‡∏¥‡πà‡∏°‚Äù
      </div>
    </div>


    <!-- ‡∏õ‡∏∏‡πà‡∏°‡πÇ‡∏´‡∏°‡∏î MANUAL -->
    <div id="manualControls" class="hidden">
      <button onclick="applySetup()">‚úì Apply</button>
      <button onclick="undo()">‚Ü© Undo</button>
      <button onclick="resetPath()">Reset Path</button>
      <button onclick="resetAll()">Reset All</button>
      <div class="hint">
        MANUAL: ‡∏Å‡∏î <kbd>Apply</kbd> ‡πÅ‡∏•‡πâ‡∏ß‡∏Ñ‡∏•‡∏¥‡∏Å‡πÄ‡∏î‡∏¥‡∏ô‡∏°‡πâ‡∏≤‡πÄ‡∏≠‡∏á (‡∏ï‡πâ‡∏≠‡∏á‡πÄ‡∏õ‡πá‡∏ô‡∏°‡∏π‡∏ü‡∏°‡πâ‡∏≤, ‡∏´‡πâ‡∏≤‡∏°‡∏ã‡πâ‡∏≥, ‡∏´‡πâ‡∏≤‡∏°‡πÄ‡∏Ç‡πâ‡∏≤‡πÅ‡∏î‡∏á) <br>
        ‡πÄ‡∏õ‡πâ‡∏≤‡∏´‡∏°‡∏≤‡∏¢‡πÄ‡∏´‡∏°‡∏∑‡∏≠‡∏ô‡∏Å‡∏±‡∏ô: ‡∏Ñ‡∏£‡∏ö‡∏ó‡∏∏‡∏Å‡∏ä‡πà‡∏≠‡∏á‡∏ó‡∏µ‡πà‡πÄ‡∏´‡∏•‡∏∑‡∏≠ + ‡∏õ‡∏¥‡∏î‡∏ß‡∏á‡∏Å‡∏•‡∏±‡∏ö start
      </div>
    </div>


    <div id="info"></div>
    <div id="result"></div>
  </div>


<script>
  const R = 5, size = 42;
  const moves = [[2,1],[2,-1],[-2,1],[-2,-1],[1,2],[1,-2],[-1,2],[-1,-2]];


  // elements
  const board = document.getElementById("board");
  const cols = document.getElementById("cols");
  const startInput = document.getElementById("startInput");
  const blockInput = document.getElementById("blockInput");
  const info = document.getElementById("info");
  const result = document.getElementById("result");
  const manualToggle = document.getElementById("manualToggle");
  const autoControls = document.getElementById("autoControls");
  const manualControls = document.getElementById("manualControls");
  const modeLabel = document.getElementById("modeLabel");
  const runBtn = document.getElementById("runBtn");


  // shared state
  let start = null, cuts = [], path = [], step = 0, finished = false;


  // manual mode
  let manualMode = false;
  let applied = false;


  function same(a,b){ return a && b && a[0]===b[0] && a[1]===b[1]; }
  function inCuts(r,c){ return cuts.some(p => p[0]===r && p[1]===c); }
  function inPath(r,c){ return path.some(p => p[0]===r && p[1]===c); }


  function parsePoint(s){
    if(!s || !s.includes(",")) return null;
    const C = +cols.value;
    let [r,c] = s.split(",").map(x => +x.trim()-1);
    if(!Number.isFinite(r) || !Number.isFinite(c)) return null;
    if(r<0||r>=R||c<0||c>=C) return null;
    return [r,c];
  }


  function readCuts(){
    const arr = [];
    const v = blockInput.value.trim();
    if(!v) return arr;
    v.split(";").forEach(s => {
      const p = parsePoint(s);
      if(!p) throw "‡∏ä‡πà‡∏≠‡∏á‡∏ï‡∏±‡∏î‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á";
      arr.push(p);
    });
    if(arr.length > 2) throw "‡∏ï‡∏±‡∏î‡πÑ‡∏î‡πâ‡πÑ‡∏°‡πà‡πÄ‡∏Å‡∏¥‡∏ô 2 ‡∏ä‡πà‡∏≠‡∏á";
    return arr;
  }


  function readInputs(){
    const C = +cols.value;
    if(C<1 || C>21) throw "n ‡∏ï‡πâ‡∏≠‡∏á‡∏≠‡∏¢‡∏π‡πà‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á 1‚Äì21";
    start = parsePoint(startInput.value);
    if(!start) throw "‡∏à‡∏∏‡∏î‡πÄ‡∏£‡∏¥‡πà‡∏°‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á";
    cuts = readCuts();
    cuts = cuts.filter(p => !same(p, start)); // ‡∏´‡πâ‡∏≤‡∏°‡∏ï‡∏±‡∏î‡∏ó‡∏±‡∏ö start
    blockInput.value = cuts.map(p => `${p[0]+1},${p[1]+1}`).join(";");
  }


  function isKnightMove(a,b){
    const dr = Math.abs(a[0]-b[0]);
    const dc = Math.abs(a[1]-b[1]);
    return (dr===2&&dc===1)||(dr===1&&dc===2);
  }


  function isCycle(p){
    if(p.length < 2) return false;
    return isKnightMove(p[0], p[p.length-1]);
  }


  function targetCount(){
    return R*(+cols.value) - cuts.length;
  }


  /* ========================= FAST AUTO SOLVER (cycle only) ========================= */


  function rngFactory(seed){
    let t = (seed>>>0) || 1;
    return ()=>((t = (t*1664525 + 1013904223)>>>0) / 4294967296);
  }


  function buildCutsSet(C){
    const set = new Set();
    for(const [r,c] of cuts) set.add(r*C + c);
    return set;
  }


  function colorOf(id, C){
    const r = Math.floor(id / C), c = id % C;
    return (r+c)&1;
  }


  function feasibleCycle(C, startId, cutsSet){
    const N = R*C;
    const target = N - cutsSet.size;


    // cycle requires even number of nodes + balanced bipartite colors
    if(target % 2 === 1) return { ok:false, why:"target ‡πÄ‡∏õ‡πá‡∏ô‡∏Ñ‡∏µ‡πà ‚Üí ‡∏õ‡∏¥‡∏î‡∏ß‡∏á‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ" };


    let w=0, b=0;
    for(let id=0; id<N; id++){
      if(cutsSet.has(id)) continue;
      (colorOf(id,C)===0) ? w++ : b++;
    }
    if(w !== b) return { ok:false, why:`‡∏™‡∏µ‡∏Ç‡∏≤‡∏ß/‡∏î‡∏≥ ‡πÑ‡∏°‡πà‡πÄ‡∏ó‡πà‡∏≤‡∏Å‡∏±‡∏ô (${w}/${b}) ‚Üí ‡∏õ‡∏¥‡∏î‡∏ß‡∏á‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ` };


    if(cutsSet.has(startId)) return { ok:false, why:"start ‡∏ñ‡∏π‡∏Å‡∏ï‡∏±‡∏î (‡∏Å‡∏±‡∏ô‡πÑ‡∏ß‡πâ)" };


    return { ok:true, target };
  }


  function buildNeighbors(C, cutsSet){
    const N = R*C;
    const neigh = Array.from({length:N}, ()=>[]);
    for(let r=0;r<R;r++){
      for(let c=0;c<C;c++){
        const id = r*C + c;
        if(cutsSet.has(id)) continue;
        for(const [dr,dc] of moves){
          const rr = r+dr, cc = c+dc;
          if(rr<0||rr>=R||cc<0||cc>=C) continue;
          const nid = rr*C + cc;
          if(cutsSet.has(nid)) continue;
          neigh[id].push(nid);
        }
      }
    }
    return neigh;
  }


  // BigInt visited bitmask
  function bitHas(mask, i){ return ((mask >> BigInt(i)) & 1n) === 1n; }
  function bitSet(mask, i){ return mask | (1n << BigInt(i)); }
  function bitClr(mask, i){ return mask & ~(1n << BigInt(i)); }


  function degree(maskVisited, list){
    let d=0;
    for(let k=0;k<list.length;k++){
      const nid = list[k];
      if(!bitHas(maskVisited, nid)) d++;
    }
    return d;
  }


  // candidates = Warnsdorff (look-ahead) + stable tie via rng value
  function buildCandidates(maskVisited, neigh, cur, rnd){
    const list = neigh[cur];
    const cand = [];
    for(let i=0;i<list.length;i++){
      const nid = list[i];
      if(bitHas(maskVisited, nid)) continue;
      const m2 = bitSet(maskVisited, nid);
      const deg = degree(m2, neigh[nid]);
      cand.push({ nid, deg, tie: rnd() });
    }
    cand.sort((a,b)=> a.deg!==b.deg ? a.deg-b.deg : a.tie-b.tie);
    return cand;
  }


  function deadEndExists(maskVisited, neigh){
    // cheap prune: if any unvisited node has 0 available moves -> impossible
    for(let id=0; id<neigh.length; id++){
      if(bitHas(maskVisited, id)) continue;
      if(degree(maskVisited, neigh[id]) === 0) return true;
    }
    return false;
  }


  function solveCycleFast(C, startId, cutsSet, neigh, seed){
    const N = R*C;
    const target = N - cutsSet.size;


    let mask = 0n;
    for(const id of cutsSet) mask = bitSet(mask, id);
    if(bitHas(mask, startId)) return null;
    mask = bitSet(mask, startId);


    if(target > 1 && neigh[startId].length < 2) return null;


    const rnd = rngFactory(seed);


    const tour = new Array(target);
    tour[0] = startId;


    const frames = []; // stack: {cand, idx}
    let depth = 1;
    let cur = startId;


    let expanded = 0;
    const MAX_EXPAND = 900000; // ‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÑ‡∏î‡πâ‡∏ñ‡πâ‡∏≤‡∏°‡∏∂‡∏á‡∏≠‡∏¢‡∏≤‡∏Å‡πÉ‡∏´‡πâ‡∏°‡∏±‡∏ô‡∏û‡∏¢‡∏≤‡∏¢‡∏≤‡∏°‡∏°‡∏≤‡∏Å‡∏Ç‡∏∂‡πâ‡∏ô


    while(true){
      if(expanded++ > MAX_EXPAND) return null;


      if(depth === target){
        const last = tour[target-1];
        const nl = neigh[last];
        for(let i=0;i<nl.length;i++){
          if(nl[i] === startId) return tour.slice();
        }
        // not closable -> backtrack
      }


      // ensure frame for current depth
      if(frames.length < depth){
        frames.push({ cand: buildCandidates(mask, neigh, cur, rnd), idx: 0 });
      }


      const f = frames[depth-1];
      if(f.idx >= f.cand.length){
        // backtrack
        frames.pop();
        if(depth === 1) return null;


        const rem = tour[depth-1];
        mask = bitClr(mask, rem);
        depth--;
        cur = tour[depth-1];
        // advance parent
        if(frames.length >= depth) frames[depth-1].idx++;
        continue;
      }


      // try current candidate
      const nextId = f.cand[f.idx].nid;
      tour[depth] = nextId;
      mask = bitSet(mask, nextId);
      cur = nextId;
      depth++;


      // prune every few steps to keep speed
      if(depth % 6 === 0){
        if(deadEndExists(mask, neigh)){
          // undo immediately
          const rem = tour[depth-1];
          mask = bitClr(mask, rem);
          depth--;
          cur = tour[depth-1];
          // advance current frame idx
          if(frames.length >= depth) frames[depth-1].idx++;
        }
      }
    }
  }


  /* ========================= AUTO UI logic ========================= */


  function runOrSkip(){
    if(manualMode) return;


    // if currently animating step-by-step, click again to skip to end
    if(path.length && !finished && step < path.length-1){
      step = path.length - 1;
      finished = true;
      drawStep();
      return;
    }


    try { runAuto(); } catch(e){ alert(e); }
  }


  function runAuto(){
    readInputs();
    applied = false;


    const C = +cols.value;
    const startId = start[0]*C + start[1];
    const cutsSet = buildCutsSet(C);


    const feas = feasibleCycle(C, startId, cutsSet);
    if(!feas.ok){
      path = [];
      step = 0;
      finished = false;
      drawStep();
      alert("‡πÄ‡∏Ñ‡∏™‡∏ô‡∏µ‡πâ‡πÄ‡∏õ‡πá‡∏ô‡πÑ‡∏õ‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ: " + feas.why);
      return;
    }


    const neigh = buildNeighbors(C, cutsSet);
    if(feas.target > 1 && neigh[startId].length < 2){
      path = [];
      step = 0;
      finished = false;
      drawStep();
      alert("‡πÄ‡∏Ñ‡∏™‡∏ô‡∏µ‡πâ‡πÄ‡∏õ‡πá‡∏ô‡πÑ‡∏õ‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ: start ‡∏°‡∏µ‡∏ó‡∏≤‡∏á‡∏≠‡∏≠‡∏Å‡∏ô‡πâ‡∏≠‡∏¢‡∏Å‡∏ß‡πà‡∏≤ 2 ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö cycle");
      return;
    }


    const base = C*100000 + (start[0]+1)*997 + (start[1]+1)*131 + cuts.length*99991;
    const MAX_RESTART = 3200; // cycle ‡∏¢‡∏≤‡∏Å‡∏Å‡∏ß‡πà‡∏≤ path ‡πÄ‡∏•‡∏¢‡πÉ‡∏´‡πâ budget ‡∏´‡∏ô‡πà‡∏≠‡∏¢
    let sol = null;


    info.textContent = "‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏´‡∏≤‡πÄ‡∏™‡πâ‡∏ô‡∏ó‡∏≤‡∏á (cycle)...";
    result.textContent = "";
    runBtn.disabled = true;


    // run sync (fast) but give UI a tick
    setTimeout(() => {
      for(let k=0; k<MAX_RESTART; k++){
        sol = solveCycleFast(C, startId, cutsSet, neigh, base + k*17);
        if(sol && sol.length === feas.target) break;
        sol = null;
      }


      runBtn.disabled = false;


      if(!sol){
        path = [];
        step = 0;
        finished = false;
        drawStep();
        info.textContent = "";
        alert("‡∏´‡∏≤ cycle ‡πÑ‡∏°‡πà‡πÄ‡∏à‡∏≠ (‡∏≠‡∏≤‡∏à‡πÄ‡∏õ‡πá‡∏ô‡πÑ‡∏õ‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ‡∏à‡∏£‡∏¥‡∏á ‡∏´‡∏£‡∏∑‡∏≠‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô start/‡∏Å‡∏≤‡∏£‡∏ï‡∏±‡∏î‡∏ä‡πà‡∏≠‡∏á)");
        return;
      }


      path = sol.map(id => [Math.floor(id / C), id % C]);
      step = 0;
      finished = false;
      drawStep();
      info.textContent = "";
    }, 10);
  }


  function next(){ if(manualMode) return; if(step < path.length-1){ step++; drawStep(); } }
  function prev(){ if(manualMode) return; if(step > 0){ step--; drawStep(); } }


  /* ========================= MANUAL mode ========================= */


  function applySetup(){
    if(!manualMode) return;
    try{
      readInputs();
      path = [start];
      step = path.length-1;
      finished = true;
      applied = true;
      drawStep();
    } catch(e){ alert(e); }
  }


  function flashCell(r,c){
    const idx = r*(+cols.value) + c;
    const el = board.children[idx];
    if(!el) return;
    el.classList.remove("illegalFlash");
    void el.offsetWidth;
    el.classList.add("illegalFlash");
  }


  function onCellClick(r,c){
    if(!manualMode) return;
    if(!applied){ flashCell(r,c); return; }
    if(inCuts(r,c)){ flashCell(r,c); return; }
    if(inPath(r,c)){ flashCell(r,c); return; }


    const last = path[path.length-1];
    const nextP = [r,c];
    if(!isKnightMove(last, nextP)){ flashCell(r,c); return; }


    path.push(nextP);
    step = path.length-1;
    finished = true;
    drawStep();
  }


  function undo(){
    if(!manualMode || !applied) return;
    if(path.length <= 1) return;
    path.pop();
    step = path.length-1;
    finished = true;
    drawStep();
  }


  function resetPath(){
    if(!manualMode || !applied) return;
    path = [start];
    step = 0;
    finished = true;
    drawStep();
  }


  /* ========================= Drawing ========================= */


  function draw(){
    const C = +cols.value;
    board.innerHTML = "";
    board.style.gridTemplateColumns = `repeat(${C},${size}px)`;


    for(let r=0;r<R;r++){
      for(let c=0;c<C;c++){
        const d = document.createElement("div");
        d.className = "cell " + ((r+c)%2 ? "black" : "white");


        if(start && start[0]==r && start[1]==c) d.classList.add("start");
        if(inCuts(r,c)) d.classList.add("blocked");


        const upto = manualMode ? (path.length-1) : step;
        for(let i=0;i<=upto && i<path.length;i++){
          const p = path[i];
          if(p[0]==r && p[1]==c){ d.textContent = i+1; break; }
        }


        if(manualMode && path.length){
          const last = path[path.length-1];
          if(last[0]===r && last[1]===c) d.classList.add("current");
        }


        d.addEventListener("click", () => onCellClick(r,c));
        board.appendChild(d);
      }
    }
  }


  function drawStep(){
    draw();
    const C = +cols.value;


    const svg = document.createElementNS("http://www.w3.org/2000/svg","svg");
    svg.setAttribute("width", C*size);
    svg.setAttribute("height", R*size);
    board.appendChild(svg);


    const upto = manualMode ? (path.length-1) : step;


    // grey lines
    for(let i=0;i<upto;i++){
      const [a,b] = path[i], [c,d] = path[i+1];
      const l = document.createElementNS(svg.namespaceURI,"line");
      l.setAttribute("x1", b*size + size/2);
      l.setAttribute("y1", a*size + size/2);
      l.setAttribute("x2", d*size + size/2);
      l.setAttribute("y2", c*size + size/2);
      l.setAttribute("stroke","rgba(200,200,200,.6)");
      l.setAttribute("stroke-width",2);
      svg.appendChild(l);
    }


    const target = targetCount();
    const shownCount = manualMode ? path.length : Math.min(step+1, path.length);
    const done = path.length && (shownCount === target);


    // red closing edge when complete cycle
    if(done && isCycle(path)){
      const [sr,sc] = path[0];
      const [er,ec] = path[path.length-1];
      const l = document.createElementNS(svg.namespaceURI,"line");
      l.setAttribute("x1", ec*size + size/2);
      l.setAttribute("y1", er*size + size/2);
      l.setAttribute("x2", sc*size + size/2);
      l.setAttribute("y2", sr*size + size/2);
      l.setAttribute("stroke","red");
      l.setAttribute("stroke-width",3);
      svg.appendChild(l);
    }


    // info/result
    if(manualMode){
      info.textContent = applied ? `‡πÄ‡∏î‡∏¥‡∏ô‡πÅ‡∏•‡πâ‡∏ß ${path.length}/${target} ‡∏ä‡πà‡∏≠‡∏á` : "‡πÇ‡∏´‡∏°‡∏î MANUAL: ‡∏Å‡∏î Apply ‡∏Å‡πà‡∏≠‡∏ô‡πÄ‡∏î‡∏¥‡∏ô";
      if(applied && path.length===target){
        result.textContent = isCycle(path) ? "üü¢ ‡∏Ñ‡∏£‡∏ö‡∏ó‡∏∏‡∏Å‡∏ä‡πà‡∏≠‡∏á ‡πÅ‡∏•‡∏∞‡∏õ‡∏¥‡∏î‡∏ß‡∏á‡πÑ‡∏î‡πâ" : "üî¥ ‡∏Ñ‡∏£‡∏ö‡πÅ‡∏ï‡πà‡πÑ‡∏°‡πà‡∏õ‡∏¥‡∏î‡∏ß‡∏á (‡πÑ‡∏°‡πà‡∏ú‡πà‡∏≤‡∏ô‡πÄ‡∏á‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏Ç)";
      } else {
        result.textContent = "";
      }
    } else {
      info.textContent = path.length
        ? `Step ${step+1}/${path.length} | ‡πÄ‡∏î‡∏¥‡∏ô ${shownCount}/${target} ‡∏ä‡πà‡∏≠‡∏á`
        : `Step 0/0 | ‡πÄ‡∏î‡∏¥‡∏ô 0/${target} ‡∏ä‡πà‡∏≠‡∏á`;


      if(path.length && step === path.length-1){
        finished = true;
        if(path.length === target){
          result.textContent = isCycle(path) ? "üü¢ ‡∏Ñ‡∏£‡∏ö‡∏ó‡∏∏‡∏Å‡∏ä‡πà‡∏≠‡∏á ‡πÅ‡∏•‡∏∞‡∏õ‡∏¥‡∏î‡∏ß‡∏á‡πÑ‡∏î‡πâ" : "üî¥ ‡∏Ñ‡∏£‡∏ö‡πÅ‡∏ï‡πà‡πÑ‡∏°‡πà‡∏õ‡∏¥‡∏î‡∏ß‡∏á (‡πÑ‡∏°‡πà‡∏ú‡πà‡∏≤‡∏ô‡πÄ‡∏á‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏Ç)";
        } else {
          result.textContent = `üü° ‡πÑ‡∏î‡πâ ${path.length}/${target} ‡∏ä‡πà‡∏≠‡∏á (‡πÑ‡∏°‡πà‡∏Ñ‡∏£‡∏ö)`;
        }
      } else {
        finished = false;
        result.textContent = "";
      }
    }
  }


  /* ========================= Reset / Mode toggle ========================= */


  function resetAll(){
    start = null; cuts = []; path = []; step = 0; finished = false;
    applied = false;
    info.textContent = ""; result.textContent = "";
    draw();
  }


  function setMode(isManual){
    manualMode = isManual;
    applied = false;
    path = [];
    step = 0;
    finished = false;


    autoControls.classList.toggle("hidden", manualMode);
    manualControls.classList.toggle("hidden", !manualMode);
    modeLabel.textContent = manualMode ? "‡∏ï‡∏≠‡∏ô‡∏ô‡∏µ‡πâ: MANUAL (‡πÇ‡∏¢‡∏á‡∏°‡∏∑‡∏≠‡πÄ‡∏≠‡∏á)" : "‡∏ï‡∏≠‡∏ô‡∏ô‡∏µ‡πâ: AUTO (‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡πÉ‡∏´‡πâ)";


    drawStep();
  }


  manualToggle.addEventListener("change", (e)=>setMode(e.target.checked));


  cols.addEventListener("change", () => {
    applied = false;
    path = [];
    step = 0;
    finished = false;
    drawStep();
  });


  // init
  draw();
</script>
</body>
</html>


